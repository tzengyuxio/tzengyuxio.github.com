<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: python | Tzeng Yuxio]]></title>
  <link href="http://tzengyuxio.me/blog/tags/python/atom.xml" rel="self"/>
  <link href="http://tzengyuxio.me/"/>
  <updated>2012-09-03T01:18:22+08:00</updated>
  <id>http://tzengyuxio.me/</id>
  <author>
    <name><![CDATA[Tzeng Yuxio]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python 與 Ruby 的模組安裝]]></title>
    <link href="http://tzengyuxio.me/blog/2012/03/29/install-module-in-python-and-ruby/"/>
    <updated>2012-03-29T08:39:00+08:00</updated>
    <id>http://tzengyuxio.me/blog/2012/03/29/install-module-in-python-and-ruby</id>
    <content type="html"><![CDATA[<p>其實這兩個語言的模組安裝都很簡單。不過我不是個成天都在安裝新玩意兒的人，偶爾因為業務需求或是心血來潮想要裝個模組，卻又忘了指令怎下，免不了得又得上網搜尋。</p>

<p>雖說資料不難找，但每次都問 google 也是折騰，索性自己記個筆記，將來若有需要時，翻自己筆記總比上網搜尋來得快速。</p>

<p>更重要的是，才不會因為上網問 google 然後<strong>開一堆網頁邊看又繼續邊開連結搞到最後開了一大堆自己好像有興趣但其實跟原本問題一點也不相干的文章</strong>。我真是太容易<em>分心</em>了。</p>

<!-- more -->


<h2>Python 的 easy_install</h2>

<p>Python 的 easy_install 人如其名，真的很 easy。比方說我看到 <a href="http://pypi.python.org/pypi/Markdown">Markdown 2.1.1 : Python Package Index</a> 這個套件想要安裝，我只要到終端機輸入下面指令就行了：</p>

<pre><code>$ easy_install markdown
</code></pre>

<p>要刪除模組的話則是輸入：</p>

<pre><code>$ easy_install -m markdown
</code></pre>

<p>easy_install 主要的功能就是安裝，如果需要進一步說明，可以參考</p>

<pre><code>$ easy_install --help
</code></pre>

<h2>Ruby 的 gem</h2>

<p>相比之下，Ruby 的 gem 就不僅僅只是個安裝工具，它是個完整的<strong>套件管理工具</strong>。例如我想安裝一個叫 <a href="http://toodledo.rubyforge.org/toodledo/">toodledo</a> 的套件，可以這麼輸入：</p>

<pre><code>$ gem install toodledo
</code></pre>

<p>或是指定版本號：</p>

<pre><code>$ gem install toodledo --version 1.3.8
</code></pre>

<p>移除的話是：</p>

<pre><code>$ gem uninstall toodledo
</code></pre>

<p>我想知道有沒有跟 markdown 相關的套件，我可以用如下方式尋找：</p>

<pre><code>$ gem list markdown --remote
</code></pre>

<p>如果沒有加上 <code>--remote</code>, 則會列出本機已經安裝的套件。</p>

<pre><code>$ gem list
</code></pre>

<p>更詳細的說明可以參考線上說明。</p>

<pre><code>$ gem help
</code></pre>

<h2>在 Mac 上</h2>

<p>上面這兩個工具程式在 Mac OS X 中都是預設已經安裝在系統中的，省了不少麻煩。安裝的過程如果有遇到權限問題，那麼就在上面所列的指令最前面加上 <code>sudo</code> 再執行就好了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 遞迴處理路徑下檔案與資料夾]]></title>
    <link href="http://tzengyuxio.me/blog/2012/01/30/python-path-walk/"/>
    <updated>2012-01-30T16:13:00+08:00</updated>
    <id>http://tzengyuxio.me/blog/2012/01/30/python-path-walk</id>
    <content type="html"><![CDATA[<p>取得某個路徑下的所有檔案與資料夾是經常會使用到的功能，尤其是在寫一些小工具來處理硬碟上的檔案時。早先我都是用傳統寫 C++ 的方式來思考，所以在 Python 的文件中找到了 <code>listdir()</code> 這個函式，然後寫了類似以下的代碼：</p>

<!-- more -->


<p>``` python
import os</p>

<p>def doInDir(somedir):</p>

<pre><code>print somedir
fileList = os.listdir(somedir)
for f in fileList:
    fullpath = os.path.join(somedir, f)
    if os.path.isdir(fullpath):
        doInDir(fullpath)
    elif os.path.isfile(fullpath):
        print fullpath
</code></pre>

<p>doInDir("/tmp/")
```</p>

<p>不過最近發現在 Python 下做事其實可以更簡單，內建的 <code>os.walk()</code> 就提供了非常強大的功能，使用的方式如下：</p>

<p>``` python
import os</p>

<p>for root, dirs, files in os.walk("/tmp/"):</p>

<pre><code>print root
for f in files:
    print os.path.join(root, f)
</code></pre>

<p>```</p>

<p>相比之下，同樣的功能用 <code>os.walk()</code> 就精簡了許多。上面兩段程式碼做的事情基本上是一樣的，都是列出指定資料夾下的所有檔案與子資料夾；不過有個小小地方需要注意一下，就是用兩種方法索處理的內部順序並不相同。<code>listdir()</code> 會按照深度優先搜索的順序，一層一層往下深入，其中檔案與資料夾的先後順序是交替穿插的；而 <code>os.walk()</code> 因為把檔案與文件夾都歸類好放在各自的 list 中，因此兩者的處理是分開的。以下是上面兩段程式針對同一個範例資料夾的輸出，可以看出處理順序的不同。</p>

<h3><code>os.walk()</code></h3>

<pre><code>/testtree/
/testtree/1file
/testtree/3file
/testtree/2dir
/testtree/2dir/21file
/testtree/2dir/24file
/testtree/2dir/22dir
/testtree/2dir/22dir/221file
/testtree/2dir/23dir
/testtree/4dir
</code></pre>

<h3><code>os.listdir()</code></h3>

<pre><code>/testtree/
/testtree/1file
/testtree/2dir
/testtree/2dir/21file
/testtree/2dir/22dir
/testtree/2dir/22dir/221file
/testtree/2dir/23dir
/testtree/2dir/24file
/testtree/3file
/testtree/4dir
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 計算檔案的 CRC32 驗證碼]]></title>
    <link href="http://tzengyuxio.me/blog/2012/01/24/python-crc32/"/>
    <updated>2012-01-24T17:02:00+08:00</updated>
    <id>http://tzengyuxio.me/blog/2012/01/24/python-crc32</id>
    <content type="html"><![CDATA[<p>用 Python 計算 CRC32 很簡單，只要使用內建的 binascii 模組即可。</p>

<p><code>python
import binascii
print binascii.crc32("hello world")
</code></p>

<p>要反覆計算的話，可以用：</p>

<p><code>python
crc = binascii.crc32("hello")
crc = binascii.crc32(" world", crc)
</code></p>

<p>其中的第二行，將前一步驟所計算的 CRC 結果作為參數再次傳入函式中。</p>

<p>如果要計算檔案的 CRC32，可以透過以下函式來計算：</p>

<!-- more -->


<p>``` python
import binascii
def computeFileCRC(filename):</p>

<pre><code>try:
    blocksize = 1024 * 64
    f = open(filename, "rb")
    str = f.read(blocksize)
    crc = 0
    while len(str) != 0:
        crc = binascii.crc32(str,crc) &amp; 0xffffffff
        str = f.read(blocksize)
    f.close()
except:
    print "compute file crc failed!"
    return 0
return crc
</code></pre>

<p>```</p>

<p>上面比較特別要注意的是這行：</p>

<p><code>python
crc = binascii.crc32(str,crc) &amp; 0xffffffff
</code></p>

<p>根據官方文件，在 Python 2.x 的版本中，binascii.crc32 所計算出來的 CRC 值域為 [-2<sup>31,</sup> 2<sup>31-1]</sup> 之間的有號整數，為了要與一般 C 所實作的 CRC 結果作比對，需要將其轉為無號整數，所以加上 <code>&amp; 0xffffffff</code> 這段來做轉換。如果是 Python 3.x 的版本，其計算結果為 [0, 2<sup>32-1]</sup> 間的無號整數，因此不需額外加上修正。</p>

<p>另外，上述 <code>computeFileCRC</code> 計算的結果為十進位整數，而通常見到的 CRC32 字串會以 16 進位方式表示，所以可以這樣轉換：</p>

<p><code>python
crcstr = hex(computeFileCRC("somefile"))[2:]
</code></p>

<p>或是，如果要直接使用在字串中，也可以用 format 的方式轉換成 16 進位格式：</p>

<p><code>python
print ("crc32: %08x" % computeFileCRC("somefile"))
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在 Eclipse 開發 Python]]></title>
    <link href="http://tzengyuxio.me/blog/2011/12/26/eclipse-for-python/"/>
    <updated>2011-12-26T11:25:00+08:00</updated>
    <id>http://tzengyuxio.me/blog/2011/12/26/eclipse-for-python</id>
    <content type="html"><![CDATA[<p>這篇文章是<a href="/blog/2011/12/26/eclipse-setup-note/">〈Eclipse 安裝筆記〉</a>系列之一，算是個人的安裝過程紀錄。以下是安裝時的環境參考：</p>

<ul>
<li>作業系統：Mac OS X 10.7.2</li>
<li>程式版本：Eclipse Indigo 3.7.1,IDE for Java Developers</li>
</ul>


<!-- more -->


<p>步驟流程如下</p>

<h3>Step 1. 準備 Python 的編譯環境</h3>

<p>同樣的，這步驟在 Mac 上可以略過。在 Windows 上要做的也很簡單，就上 Python 官網抓個 Python Binary 來安裝就好了。相對於 C++ 的準備工作來得簡單些。</p>

<h3>Step 2. 安裝 PyDev</h3>

<p>在 Eclipse Indigo 之後，套件的安裝變得簡單許多，只要透過滑鼠就可以搞定。首先，先上 <a href="http://marketplace.eclipse.org">Eclipse Marketplace</a>, 一個類似 firefox Extensions 或 Android Market 的地方。搜尋「pydev」，找到後點進去套件頁面，在套件 Logo 下可以看到一個「Install」按鈕，只要將該按鈕拖曳到 Eclipse 視窗中，就可以開始安裝了。</p>

<p><span class='caption-wrapper'><img class='caption' src='http://3.bp.blogspot.com/-C_V3nxc2Z0I/TvfjPTDCbfI/AAAAAAAAJFU/ygD2IDbYz1k/s800/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2011-12-26+%25E4%25B8%258A%25E5%258D%258810.58.51.png' width='' height='' alt='拖曳圖中紫色說明區塊所指向的按鈕就能直接安裝' title='拖曳圖中紫色說明區塊所指向的按鈕就能直接安裝'><span class='caption-text'>拖曳圖中紫色說明區塊所指向的按鈕就能直接安裝</span></span></p>

<h3>Step 3. 開始寫 Python</h3>

<p>安裝完後重開 Eclipse，如果在選單「File」→「New」→「Project」的對話視窗有看到如下圖的 PyDev 選項資料夾，就表示安裝成功了，可以開始寫 Python 的程式。</p>

<p><img src="http://1.bp.blogspot.com/-kvvmlpzhScs/TvfoxGUi98I/AAAAAAAAJFs/xaKtFOwcTQk/s800/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2011-12-26+%25E4%25B8%258A%25E5%258D%258811.08.08.png" alt="" /></p>

<p>不過，等等，要讓齒輪動起來，還少了點東西。CDT 可以自動找到 C++ Compiler 的所在，可是 PyDev 不行，我們得手動指定 Python 直譯器的路徑。</p>

<p>從選單列開啟 Eclipse 的「偏好設定」，切到 PyDev 如下的頁面，點選上半部視窗的「New...」按鈕，輸入路徑 <code>/usr/bin/python</code>，至於名字可以任意輸入，我習慣加上個版本號。完成之後，PyDev 會自動抓取 <code>PYTHONPATH</code>，也就是下圖中下半部份的視窗。好在這部份不用傷神輸入。</p>

<p><img src="http://2.bp.blogspot.com/--dQy7oHi8XU/Tvfockstk5I/AAAAAAAAJFg/s59aFMnJvZ4/s800/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2011-12-26+%25E4%25B8%258A%25E5%258D%258811.18.55.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eclipse 安裝筆記 - 前言與目錄]]></title>
    <link href="http://tzengyuxio.me/blog/2011/12/26/eclipse-setup-note/"/>
    <updated>2011-12-26T04:17:00+08:00</updated>
    <id>http://tzengyuxio.me/blog/2011/12/26/eclipse-setup-note</id>
    <content type="html"><![CDATA[<p>用了 Eclipse 也好一陣子了，不過每次需要重新安裝 Eclipse 的時候，或多或少總還是會遇到一些問題。雖然說現在網路很方便，google 一下都可以找到這些問題的解決方式，但為了這些問題免不了又是花上一些時間在搜尋與嘗試上，許多甚至還是以前遇過又重新碰到的問題。因此，不如乾脆自己寫點筆記，既加深印象，就算下次忘了，至少也不用再到茫茫網海中搜尋解決方案。</p>

<p><a href="http://3.bp.blogspot.com/-NjNp_x0dh8E/TveErHlc8nI/AAAAAAAAJD4/RGELy-s4xto/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2011-12-26+%25E4%25B8%258A%25E5%258D%25884.15.34.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="172" src="http://3.bp.blogspot.com/-NjNp_x0dh8E/TveErHlc8nI/AAAAAAAAJD4/RGELy-s4xto/s320/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2011-12-26+%25E4%25B8%258A%25E5%258D%25884.15.34.png" width="320" /></a></p>

<!-- more -->


<p>先列出我的 Eclipse 開發環境需求：</p>

<ul>
<li>程式語言：C++, Java, Python</li>
<li>版本管理：Subversion, Git</li>
</ul>


<p>應該還算簡單。其實還有一些其他想裝的，比方說 php 或 Lua 或 JavaScript 或 Mercurial，這些都是將來哪天說不準會用到的東西。要是以前的我，可能就會想說一開始就全部裝到好，一次搞定；不過現在的我比較傾向<strong>「還沒用到的東西就先不安裝」</strong>，因為可能就真的一直都用不到，裝了也不過是裝個心安而已。專案開發也是一樣道理，我們經常在分析設計時加入過多的功能與設計，然而許多時候這些功能或設計都是壓根用不到或是不被需要的，這點有機會的話再討論，此處就不多做贅言。</p>

<p>在目前主流的三大 IDE 中，我一直覺得 Eclipse 是最不友善的一個，儘管它的功能很強大，擴充上也具有彈性。<strong>Eclipse 的不友善，從下載時候就開始了</strong>，官網上提供各種功能不同的 Package，看似方便，其實增加許多障礙。我在教學時，超過一半的學生在下載這邊就會卡住；即便是有經驗的程式設計師，要是他有開發 C++ 與 Java 的需求，第一次來到 Eclipse 的下載頁面，相信他也會面臨第一道選擇題：</p>

<blockquote><p>到底我要下載 for Java 的版本還是 for C/C++ 的版本還是都下載？</p></blockquote>

<p>當然，有經驗的 Eclipse 開發者知道各個語言的開發套件都可以事後安裝，進一步說，Eclipse 用來安裝擴充套件的「Install New Software」幾乎是每個 Eclipse 開發者都會使用到的功能，至少你得安裝個 CVS 以外的版本控制系統。既然如此，那麼何不一開始就只提供一個不含開發語言的 Eclipse 包，第一次執行時便強制讓使用者透過「Install New Software」的機制來選擇要使用的開發語言，順便也是強迫學習「Install New Software」的流程。</p>

<p>不過話說回來，這個「Install New Software」的功能設計的也不友善就是。或許我早被荼毒已久，自己使用上還沒感覺，可是在看學生操作時，才發現「Install New Software」的 UI 處處是陷阱，很難第一時間了解要以什麼樣的順序在什麼地方輸入什麼資料。</p>

<p>還有一點要抱怨的是，Eclipse 裡的術語眾多，頭字語滿天飛，CDT, RAP, ATF 什麼的一堆，我要裝個 Git 還得先搞懂 EGit 跟 JGit 到底有什麼差別。術語和頭字語的問題在程式語言開發的領域中在所難免，這我可以理解，可是 Eclipse 的世界中硬是比其他開發環境多出許多，一眼看去彷彿有字天書。<u>工具是用來解決問題的，不過這下反而製造了更多的問題讓使用者學習。</u>寫到這裡我突然想感謝 Microsoft 沒有在 Visual Studio 的安裝介面選項中將「Microsoft SQL Server」縮寫成 MSS。</p>

<p>啦哩拉雜提了一堆，該回到正題。我的 Eclipse 安裝了以下套件：</p>

<ul>
<li><a href="http://www.eclipse.org/cdt/downloads.php">C/C++ Development Tooling (CDT)</a></li>
<li><a href="http://marketplace.eclipse.org/content/pydev-python-ide-eclipse">PyDev - Python IDE for Eclipse</a></li>
<li><a href="http://eclipse.org/egit/downloads">EGit - Git Team Provider</a></li>
<li><a href="http://marketplace.eclipse.org/content/subclipse">Subclipse</a></li>
<li><a href="http://marketplace.eclipse.org/content/eclipse-color-theme">Eclipse Color Theme</a> 主要是為了 <a href="http://slinky.imukuppi.org/zenburn/">zenburn</a> 這個 color theme</li>
</ul>


<p>為了方便起見，分成以下四篇文章說明：</p>

<ul>
<li><a href="/blog/2011/12/26/eclipse-for-cplusplus/">在 Eclipse 開發 C/C++</a></li>
<li><a href="/blog/2011/12/26/eclipse-for-python/">在 Eclipse 開發 Python</a></li>
<li><a href="/blog/2011/12/26/eclipse-with-git-and-svn/">在 Eclipse 使用 Git 與 SVN</a></li>
<li><a href="/blog/2011/12/27/my-eclipse-settings/">我的 Eclipse 初始設定調教</a></li>
</ul>


<p>最後補充一點說明，我的安裝環境是 Mac OS X, 所以 C++ 的 compiler 與 Python 的 interpreter 都已經系統內建。在 Windows 上對應的話，得要先安裝個 MinGW 與 Python for Windows 來提供編譯與直譯環境。</p>
]]></content>
  </entry>
  
</feed>
